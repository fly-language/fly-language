"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var smodel_1 = require("../../base/model/smodel");
var vnode_utils_1 = require("../../base/views/vnode-utils");
var sgraph_1 = require("../../graph/sgraph");
var geometry_1 = require("../../utils/geometry");
var model_1 = require("../bounds/model");
var model_2 = require("./model");
var routing_1 = require("../routing/routing");
var EdgeLayoutPostprocessor = /** @class */ (function () {
    function EdgeLayoutPostprocessor() {
    }
    EdgeLayoutPostprocessor.prototype.decorate = function (vnode, element) {
        if (model_2.isEdgeLayoutable(element) && element.parent instanceof sgraph_1.SEdge) {
            if (element.bounds !== geometry_1.EMPTY_BOUNDS) {
                var placement = this.getEdgePlacement(element);
                var edge = element.parent;
                var position = Math.min(1, Math.max(0, placement.position));
                var router = this.edgeRouterRegistry.get(edge.routerKind);
                var pointOnEdge = router.pointAt(edge, position);
                var derivativeOnEdge = router.derivativeAt(edge, position);
                var transform = '';
                if (pointOnEdge && derivativeOnEdge) {
                    transform += "translate(" + pointOnEdge.x + ", " + pointOnEdge.y + ")";
                    var angle = geometry_1.toDegrees(Math.atan2(derivativeOnEdge.y, derivativeOnEdge.x));
                    if (placement.rotate) {
                        var flippedAngle = angle;
                        if (Math.abs(angle) > 90) {
                            if (angle < 0)
                                flippedAngle += 180;
                            else if (angle > 0)
                                flippedAngle -= 180;
                        }
                        transform += " rotate(" + flippedAngle + ")";
                        var alignment = this.getRotatedAlignment(element, placement, flippedAngle !== angle);
                        transform += " translate(" + alignment.x + ", " + alignment.y + ")";
                    }
                    else {
                        var alignment = this.getAlignment(element, placement, angle);
                        transform += " translate(" + alignment.x + ", " + alignment.y + ")";
                    }
                    vnode_utils_1.setAttr(vnode, 'transform', transform);
                }
            }
        }
        return vnode;
    };
    EdgeLayoutPostprocessor.prototype.getRotatedAlignment = function (element, placement, flip) {
        var x = model_1.isAlignable(element) ? element.alignment.x : 0;
        var y = model_1.isAlignable(element) ? element.alignment.y : 0;
        var bounds = element.bounds;
        if (placement.side === 'on')
            return { x: x - 0.5 * bounds.height, y: y - 0.5 * bounds.height };
        if (flip) {
            if (placement.position < 0.3333333)
                x -= bounds.width + placement.offset;
            else if (placement.position < 0.6666666)
                x -= 0.5 * bounds.width;
            else
                x += placement.offset;
            switch (placement.side) {
                case 'left':
                case 'bottom':
                    y -= placement.offset + bounds.height;
                    break;
                case 'right':
                case 'top':
                    y += placement.offset;
            }
        }
        else {
            if (placement.position < 0.3333333)
                x += placement.offset;
            else if (placement.position < 0.6666666)
                x -= 0.5 * bounds.width;
            else
                x -= bounds.width + placement.offset;
            switch (placement.side) {
                case 'right':
                case 'bottom':
                    y += -placement.offset - bounds.height;
                    break;
                case 'left':
                case 'top':
                    y += placement.offset;
            }
        }
        return { x: x, y: y };
    };
    EdgeLayoutPostprocessor.prototype.getEdgePlacement = function (element) {
        var current = element;
        var allPlacements = [];
        while (current !== undefined) {
            var placement = current.edgePlacement;
            if (placement !== undefined)
                allPlacements.push(placement);
            if (current instanceof smodel_1.SChildElement)
                current = current.parent;
            else
                break;
        }
        return allPlacements.reverse().reduce(function (a, b) { return __assign(__assign({}, a), b); }, model_2.DEFAULT_EDGE_PLACEMENT);
    };
    EdgeLayoutPostprocessor.prototype.getAlignment = function (label, placement, angle) {
        var bounds = label.bounds;
        var x = model_1.isAlignable(label) ? label.alignment.x - bounds.width : 0;
        var y = model_1.isAlignable(label) ? label.alignment.y - bounds.height : 0;
        if (placement.side === 'on')
            return { x: x + 0.5 * bounds.height, y: y + 0.5 * bounds.height };
        var quadrant = this.getQuadrant(angle);
        var midLeft = { x: placement.offset, y: y + 0.5 * bounds.height };
        var topLeft = { x: placement.offset, y: y + bounds.height + placement.offset };
        var topRight = { x: -bounds.width - placement.offset, y: y + bounds.height + placement.offset };
        var midRight = { x: -bounds.width - placement.offset, y: y + 0.5 * bounds.height };
        var bottomRight = { x: -bounds.width - placement.offset, y: y - placement.offset };
        var bottomLeft = { x: placement.offset, y: y - placement.offset };
        switch (placement.side) {
            case 'left':
                switch (quadrant.orientation) {
                    case 'west':
                        return geometry_1.linear(topLeft, topRight, quadrant.position);
                    case 'north':
                        return geometry_1.linear(topRight, bottomRight, quadrant.position);
                    case 'east':
                        return geometry_1.linear(bottomRight, bottomLeft, quadrant.position);
                    case 'south':
                        return geometry_1.linear(bottomLeft, topLeft, quadrant.position);
                }
                break;
            case 'right':
                switch (quadrant.orientation) {
                    case 'west':
                        return geometry_1.linear(bottomRight, bottomLeft, quadrant.position);
                    case 'north':
                        return geometry_1.linear(bottomLeft, topLeft, quadrant.position);
                    case 'east':
                        return geometry_1.linear(topLeft, topRight, quadrant.position);
                    case 'south':
                        return geometry_1.linear(topRight, bottomRight, quadrant.position);
                }
                break;
            case 'top':
                switch (quadrant.orientation) {
                    case 'west':
                        return geometry_1.linear(bottomRight, bottomLeft, quadrant.position);
                    case 'north':
                        return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
                    case 'east':
                        return geometry_1.linear(bottomRight, bottomLeft, quadrant.position);
                    case 'south':
                        return this.linearFlip(bottomLeft, midLeft, midRight, bottomRight, quadrant.position);
                }
                break;
            case 'bottom':
                switch (quadrant.orientation) {
                    case 'west':
                        return geometry_1.linear(topLeft, topRight, quadrant.position);
                    case 'north':
                        return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
                    case 'east':
                        return geometry_1.linear(topLeft, topRight, quadrant.position);
                    case 'south':
                        return this.linearFlip(topRight, midRight, midLeft, topLeft, quadrant.position);
                }
                break;
        }
        return { x: 0, y: 0 };
    };
    EdgeLayoutPostprocessor.prototype.getQuadrant = function (angle) {
        if (Math.abs(angle) > 135)
            return { orientation: 'west', position: (angle > 0 ? angle - 135 : angle + 225) / 90 };
        else if (angle < -45)
            return { orientation: 'north', position: (angle + 135) / 90 };
        else if (angle < 45)
            return { orientation: 'east', position: (angle + 45) / 90 };
        else
            return { orientation: 'south', position: (angle - 45) / 90 };
    };
    EdgeLayoutPostprocessor.prototype.linearFlip = function (p0, p1, p2, p3, position) {
        return position < 0.5 ? geometry_1.linear(p0, p1, 2 * position) : geometry_1.linear(p2, p3, 2 * position - 1);
    };
    EdgeLayoutPostprocessor.prototype.postUpdate = function () { };
    __decorate([
        inversify_1.inject(routing_1.EdgeRouterRegistry),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
    ], EdgeLayoutPostprocessor.prototype, "edgeRouterRegistry", void 0);
    EdgeLayoutPostprocessor = __decorate([
        inversify_1.injectable()
    ], EdgeLayoutPostprocessor);
    return EdgeLayoutPostprocessor;
}());
exports.EdgeLayoutPostprocessor = EdgeLayoutPostprocessor;
//# sourceMappingURL=edge-layout.js.map