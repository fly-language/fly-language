"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var types_1 = require("../types");
var smodel_factory_1 = require("../model/smodel-factory");
var smodel_1 = require("../model/smodel");
var animation_frame_syncer_1 = require("../animations/animation-frame-syncer");
var command_1 = require("./command");
/**
 * The implementation of the ICommandStack. Clients should not use this
 * class directly.
 *
 * The command stack holds the current model as the result of the current
 * promise. When a new command is executed/undone/redone, its execution is
 * chained using <code>Promise#then()</code> to the current Promise. This
 * way we can handle long running commands without blocking the current
 * thread.
 *
 * The command stack also does the special handling for special commands:
 *
 * System commands should be transparent to the user and as such be
 * automatically undone/redone with the next plain command. Additional care
 * must be taken that system commands that are executed after undo don't
 * break the correspondence between the topmost commands on the undo and
 * redo stacks.
 *
 * Hidden commands only tell the viewer to render a hidden model such that
 * its bounds can be extracted from the DOM and forwarded as separate actions.
 * Hidden commands should not leave any trace on the undo/redo/off stacks.
 *
 * Mergeable commands should be merged with their predecessor if possible,
 * such that e.g. multiple subsequent moves of the smae element can be undone
 * in one single step.
 */
var CommandStack = /** @class */ (function () {
    function CommandStack() {
        this.undoStack = [];
        this.redoStack = [];
        /**
         * System commands should be transparent to the user in undo/redo
         * operations. When a system command is executed when the redo
         * stack is not empty, it is pushed to offStack instead.
         *
         * On redo, all commands form this stack are undone such that the
         * redo operation gets the exact same model as when it was executed
         * first.
         *
         * On undo, all commands form this stack are undone as well as
         * system ommands should be transparent to the user.
         */
        this.offStack = [];
    }
    CommandStack.prototype.initialize = function () {
        this.currentPromise = Promise.resolve({
            main: {
                model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
                modelChanged: false,
            },
            hidden: {
                model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
                modelChanged: false,
            },
            popup: {
                model: this.modelFactory.createRoot(smodel_factory_1.EMPTY_ROOT),
                modelChanged: false,
            }
        });
    };
    Object.defineProperty(CommandStack.prototype, "currentModel", {
        get: function () {
            return this.currentPromise.then(function (state) { return state.main.model; });
        },
        enumerable: true,
        configurable: true
    });
    CommandStack.prototype.executeAll = function (commands) {
        var _this = this;
        commands.forEach(function (command) {
            _this.logger.log(_this, 'Executing', command);
            _this.handleCommand(command, command.execute, _this.mergeOrPush);
        });
        return this.thenUpdate();
    };
    CommandStack.prototype.execute = function (command) {
        this.logger.log(this, 'Executing', command);
        this.handleCommand(command, command.execute, this.mergeOrPush);
        return this.thenUpdate();
    };
    CommandStack.prototype.undo = function () {
        var _this = this;
        this.undoOffStackSystemCommands();
        this.undoPreceedingSystemCommands();
        var command = this.undoStack[this.undoStack.length - 1];
        if (command !== undefined && !this.isBlockUndo(command)) {
            this.undoStack.pop();
            this.logger.log(this, 'Undoing', command);
            this.handleCommand(command, command.undo, function (c, context) {
                _this.redoStack.push(c);
            });
        }
        return this.thenUpdate();
    };
    CommandStack.prototype.redo = function () {
        var _this = this;
        this.undoOffStackSystemCommands();
        var command = this.redoStack.pop();
        if (command !== undefined) {
            this.logger.log(this, 'Redoing', command);
            this.handleCommand(command, command.redo, function (c, context) {
                _this.pushToUndoStack(c);
            });
        }
        this.redoFollowingSystemCommands();
        return this.thenUpdate();
    };
    /**
     * Chains the current promise with another Promise that performs the
     * given operation on the given command.
     *
     * @param beforeResolve a function that is called directly before
     *      resolving the Promise to return the new model. Usually puts the
     *      command on the appropriate stack.
     */
    CommandStack.prototype.handleCommand = function (command, operation, beforeResolve) {
        var _this = this;
        this.currentPromise = this.currentPromise.then(function (state) {
            return new Promise(function (resolve) {
                var target;
                if (command instanceof command_1.HiddenCommand)
                    target = 'hidden';
                else if (command instanceof command_1.PopupCommand)
                    target = 'popup';
                else
                    target = 'main';
                var context = _this.createContext(state.main.model);
                var commandResult;
                try {
                    commandResult = operation.call(command, context);
                }
                catch (error) {
                    _this.logger.error(_this, "Failed to execute command:", error);
                    commandResult = state[target].model;
                }
                var newState = copyState(state);
                if (commandResult instanceof Promise) {
                    commandResult.then(function (newModel) {
                        if (target === 'main')
                            beforeResolve.call(_this, command, context);
                        newState[target] = { model: newModel, modelChanged: true };
                        resolve(newState);
                    });
                }
                else if (commandResult instanceof smodel_1.SModelRoot) {
                    if (target === 'main')
                        beforeResolve.call(_this, command, context);
                    newState[target] = { model: commandResult, modelChanged: true };
                    resolve(newState);
                }
                else {
                    if (target === 'main')
                        beforeResolve.call(_this, command, context);
                    newState[target] = {
                        model: commandResult.model,
                        modelChanged: state[target].modelChanged || commandResult.modelChanged,
                        cause: commandResult.cause
                    };
                    resolve(newState);
                }
            });
        });
    };
    CommandStack.prototype.pushToUndoStack = function (command) {
        this.undoStack.push(command);
        if (this.options.undoHistoryLimit >= 0 && this.undoStack.length > this.options.undoHistoryLimit)
            this.undoStack.splice(0, this.undoStack.length - this.options.undoHistoryLimit);
    };
    /**
     * Notifies the Viewer to render the new model and/or the new hidden model
     * and returns a Promise for the new model.
     */
    CommandStack.prototype.thenUpdate = function () {
        var _this = this;
        this.currentPromise = this.currentPromise.then(function (state) {
            var newState = copyState(state);
            if (state.hidden.modelChanged) {
                _this.updateHidden(state.hidden.model, state.hidden.cause);
                newState.hidden.modelChanged = false;
                newState.hidden.cause = undefined;
            }
            if (state.main.modelChanged) {
                _this.update(state.main.model, state.main.cause);
                newState.main.modelChanged = false;
                newState.main.cause = undefined;
            }
            if (state.popup.modelChanged) {
                _this.updatePopup(state.popup.model, state.popup.cause);
                newState.popup.modelChanged = false;
                newState.popup.cause = undefined;
            }
            return newState;
        });
        return this.currentModel;
    };
    /**
     * Notify the `ModelViewer` that the model has changed.
     */
    CommandStack.prototype.update = function (model, cause) {
        if (this.modelViewer === undefined) {
            this.modelViewer = this.viewerProvider.modelViewer;
        }
        this.modelViewer.update(model, cause);
    };
    /**
     * Notify the `HiddenModelViewer` that the hidden model has changed.
     */
    CommandStack.prototype.updateHidden = function (model, cause) {
        if (this.hiddenModelViewer === undefined) {
            this.hiddenModelViewer = this.viewerProvider.hiddenModelViewer;
        }
        this.hiddenModelViewer.update(model, cause);
    };
    /**
     * Notify the `PopupModelViewer` that the popup model has changed.
     */
    CommandStack.prototype.updatePopup = function (model, cause) {
        if (this.popupModelViewer === undefined) {
            this.popupModelViewer = this.viewerProvider.popupModelViewer;
        }
        this.popupModelViewer.update(model, cause);
    };
    /**
     * Handling of commands after their execution.
     *
     * Hidden commands are not pushed to any stack.
     *
     * System commands are pushed to the <code>offStack</code> when the redo
     * stack is not empty, allowing to undo the before a redo to keep the chain
     * of commands consistent.
     *
     * Mergable commands are merged if possible.
     */
    CommandStack.prototype.mergeOrPush = function (command, context) {
        var _this = this;
        if (this.isBlockUndo(command)) {
            this.undoStack = [];
            this.redoStack = [];
            this.offStack = [];
            this.pushToUndoStack(command);
            return;
        }
        if (this.isPushToOffStack(command) && this.redoStack.length > 0) {
            if (this.offStack.length > 0) {
                var lastCommand = this.offStack[this.offStack.length - 1];
                if (lastCommand instanceof command_1.MergeableCommand && lastCommand.merge(command, context))
                    return;
            }
            this.offStack.push(command);
            return;
        }
        if (this.isPushToUndoStack(command)) {
            this.offStack.forEach(function (c) { return _this.undoStack.push(c); });
            this.offStack = [];
            this.redoStack = [];
            if (this.undoStack.length > 0) {
                var lastCommand = this.undoStack[this.undoStack.length - 1];
                if (lastCommand instanceof command_1.MergeableCommand && lastCommand.merge(command, context))
                    return;
            }
            this.pushToUndoStack(command);
        }
    };
    /**
     * Reverts all system commands on the offStack.
     */
    CommandStack.prototype.undoOffStackSystemCommands = function () {
        var command = this.offStack.pop();
        while (command !== undefined) {
            this.logger.log(this, 'Undoing off-stack', command);
            this.handleCommand(command, command.undo, function () { });
            command = this.offStack.pop();
        }
    };
    /**
     * System commands should be transparent to the user, so this method
     * is called from <code>undo()</code> to revert all system commands
     * at the top of the undoStack.
     */
    CommandStack.prototype.undoPreceedingSystemCommands = function () {
        var _this = this;
        var command = this.undoStack[this.undoStack.length - 1];
        while (command !== undefined && this.isPushToOffStack(command)) {
            this.undoStack.pop();
            this.logger.log(this, 'Undoing', command);
            this.handleCommand(command, command.undo, function (c, context) {
                _this.redoStack.push(c);
            });
            command = this.undoStack[this.undoStack.length - 1];
        }
    };
    /**
     * System commands should be transparent to the user, so this method
     * is called from <code>redo()</code> to re-execute all system commands
     * at the top of the redoStack.
     */
    CommandStack.prototype.redoFollowingSystemCommands = function () {
        var _this = this;
        var command = this.redoStack[this.redoStack.length - 1];
        while (command !== undefined && this.isPushToOffStack(command)) {
            this.redoStack.pop();
            this.logger.log(this, 'Redoing ', command);
            this.handleCommand(command, command.redo, function (c, context) {
                _this.pushToUndoStack(c);
            });
            command = this.redoStack[this.redoStack.length - 1];
        }
    };
    /**
     * Assembles the context object that is passed to the commands execution method.
     */
    CommandStack.prototype.createContext = function (currentModel) {
        return {
            root: currentModel,
            modelChanged: this,
            modelFactory: this.modelFactory,
            duration: this.options.defaultDuration,
            logger: this.logger,
            syncer: this.syncer
        };
    };
    CommandStack.prototype.isPushToOffStack = function (command) {
        return command instanceof command_1.SystemCommand;
    };
    CommandStack.prototype.isPushToUndoStack = function (command) {
        return !(command instanceof command_1.HiddenCommand);
    };
    CommandStack.prototype.isBlockUndo = function (command) {
        return command instanceof command_1.ResetCommand;
    };
    __decorate([
        inversify_1.inject(types_1.TYPES.IModelFactory),
        __metadata("design:type", Object)
    ], CommandStack.prototype, "modelFactory", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.IViewerProvider),
        __metadata("design:type", Object)
    ], CommandStack.prototype, "viewerProvider", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
    ], CommandStack.prototype, "logger", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
    ], CommandStack.prototype, "syncer", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.CommandStackOptions),
        __metadata("design:type", Object)
    ], CommandStack.prototype, "options", void 0);
    __decorate([
        inversify_1.postConstruct(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CommandStack.prototype, "initialize", null);
    CommandStack = __decorate([
        inversify_1.injectable()
    ], CommandStack);
    return CommandStack;
}());
exports.CommandStack = CommandStack;
function copyState(state) {
    return {
        main: __assign({}, state.main),
        hidden: __assign({}, state.hidden),
        popup: __assign({}, state.popup)
    };
}
//# sourceMappingURL=command-stack.js.map