"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("../types");
var smodel_1 = require("./smodel");
/**
 * Register a model element constructor for an element type.
 */
function registerModelElement(context, type, constr, features) {
    context.bind(types_1.TYPES.SModelElementRegistration).toConstantValue({
        type: type, constr: constr, features: features
    });
}
exports.registerModelElement = registerModelElement;
/**
 * Model element types can include a colon to separate the basic type and a sub-type. This function
 * extracts the basic type of a model element.
 */
function getBasicType(schema) {
    if (!schema.type)
        return '';
    var colonIndex = schema.type.indexOf(':');
    if (colonIndex >= 0)
        return schema.type.substring(0, colonIndex);
    else
        return schema.type;
}
exports.getBasicType = getBasicType;
/**
 * Model element types can include a colon to separate the basic type and a sub-type. This function
 * extracts the sub-type of a model element.
 */
function getSubType(schema) {
    if (!schema.type)
        return '';
    var colonIndex = schema.type.indexOf(':');
    if (colonIndex >= 0)
        return schema.type.substring(colonIndex + 1);
    else
        return schema.type;
}
exports.getSubType = getSubType;
/**
 * Find the element with the given identifier. If you need to find multiple elements, using an
 * SModelIndex might be more effective.
 */
function findElement(parent, elementId) {
    if (parent.id === elementId)
        return parent;
    if (parent.children !== undefined) {
        for (var _i = 0, _a = parent.children; _i < _a.length; _i++) {
            var child = _a[_i];
            var result = findElement(child, elementId);
            if (result !== undefined)
                return result;
        }
    }
    return undefined;
}
exports.findElement = findElement;
/**
 * Find a parent element that satisfies the given predicate.
 */
function findParent(element, predicate) {
    var current = element;
    while (current !== undefined) {
        if (predicate(current))
            return current;
        else if (current instanceof smodel_1.SChildElement)
            current = current.parent;
        else
            current = undefined;
    }
    return current;
}
exports.findParent = findParent;
/**
 * Find a parent element that implements the feature identified with the given predicate.
 */
function findParentByFeature(element, predicate) {
    var current = element;
    while (current !== undefined) {
        if (predicate(current))
            return current;
        else if (current instanceof smodel_1.SChildElement)
            current = current.parent;
        else
            current = undefined;
    }
    return current;
}
exports.findParentByFeature = findParentByFeature;
/**
 * Translate a point from the coordinate system of the source element to the coordinate system
 * of the target element.
 */
function translatePoint(point, source, target) {
    if (source !== target) {
        // Translate from the source to the root element
        while (source instanceof smodel_1.SChildElement) {
            point = source.localToParent(point);
            source = source.parent;
            if (source === target)
                return point;
        }
        // Translate from the root to the target element
        var targetTrace = [];
        while (target instanceof smodel_1.SChildElement) {
            targetTrace.push(target);
            target = target.parent;
        }
        if (source !== target)
            throw new Error("Incompatible source and target: " + source.id + ", " + target.id);
        for (var i = targetTrace.length - 1; i >= 0; i--) {
            point = targetTrace[i].parentToLocal(point);
        }
    }
    return point;
}
exports.translatePoint = translatePoint;
/**
 * Translate some bounds from the coordinate system of the source element to the coordinate system
 * of the target element.
 */
function translateBounds(bounds, source, target) {
    var upperLeft = translatePoint(bounds, source, target);
    var lowerRight = translatePoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, source, target);
    return {
        x: upperLeft.x,
        y: upperLeft.y,
        width: lowerRight.x - upperLeft.x,
        height: lowerRight.y - upperLeft.y
    };
}
exports.translateBounds = translateBounds;
//# sourceMappingURL=smodel-utils.js.map