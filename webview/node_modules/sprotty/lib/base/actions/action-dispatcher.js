"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var types_1 = require("../types");
var async_1 = require("../../utils/async");
var smodel_factory_1 = require("../model/smodel-factory");
var animation_frame_syncer_1 = require("../animations/animation-frame-syncer");
var set_model_1 = require("../features/set-model");
var undo_redo_1 = require("../../features/undo-redo/undo-redo");
var action_1 = require("./action");
/**
 * Collects actions, converts them to commands and dispatches them.
 * Also acts as the proxy to model sources such as diagram servers.
 */
var ActionDispatcher = /** @class */ (function () {
    function ActionDispatcher() {
        this.postponedActions = [];
        this.requests = new Map();
    }
    ActionDispatcher.prototype.initialize = function () {
        var _this = this;
        if (!this.initialized) {
            this.initialized = this.actionHandlerRegistryProvider().then(function (registry) {
                _this.actionHandlerRegistry = registry;
                _this.handleAction(new set_model_1.SetModelAction(smodel_factory_1.EMPTY_ROOT));
            });
        }
        return this.initialized;
    };
    /**
     * Dispatch an action by querying all handlers that are registered for its kind.
     * The returned promise is resolved when all handler results (commands or actions)
     * have been processed.
     */
    ActionDispatcher.prototype.dispatch = function (action) {
        var _this = this;
        return this.initialize().then(function () {
            if (_this.blockUntil !== undefined) {
                return _this.handleBlocked(action, _this.blockUntil);
            }
            else if (_this.diagramLocker.isAllowed(action)) {
                return _this.handleAction(action);
            }
            return undefined;
        });
    };
    /**
     * Calls `dispatch` on every action in the given array. The returned promise
     * is resolved when the promises of all `dispatch` calls have been resolved.
     */
    ActionDispatcher.prototype.dispatchAll = function (actions) {
        var _this = this;
        return Promise.all(actions.map(function (action) { return _this.dispatch(action); }));
    };
    /**
     * Dispatch a request. The returned promise is resolved when a response with matching
     * identifier is dispatched. That response is _not_ passed to the registered action
     * handlers. Instead, it is the responsibility of the caller of this method to handle
     * the response properly. For example, it can be sent to the registered handlers by
     * passing it again to the `dispatch` method.
     */
    ActionDispatcher.prototype.request = function (action) {
        if (!action.requestId) {
            return Promise.reject(new Error('Request without requestId'));
        }
        var deferred = new async_1.Deferred();
        this.requests.set(action.requestId, deferred);
        this.dispatch(action);
        return deferred.promise;
    };
    ActionDispatcher.prototype.handleAction = function (action) {
        if (action.kind === undo_redo_1.UndoAction.KIND) {
            return this.commandStack.undo().then(function () { });
        }
        if (action.kind === undo_redo_1.RedoAction.KIND) {
            return this.commandStack.redo().then(function () { });
        }
        if (action_1.isResponseAction(action)) {
            var deferred = this.requests.get(action.responseId);
            if (deferred !== undefined) {
                this.requests.delete(action.responseId);
                if (action.kind === action_1.RejectAction.KIND) {
                    var rejectAction = action;
                    deferred.reject(new Error(rejectAction.message));
                    this.logger.warn(this, "Request with id " + action.responseId + " failed.", rejectAction.message, rejectAction.detail);
                }
                else {
                    deferred.resolve(action);
                }
                return Promise.resolve();
            }
            this.logger.log(this, 'No matching request for response', action);
        }
        var handlers = this.actionHandlerRegistry.get(action.kind);
        if (handlers.length === 0) {
            this.logger.warn(this, 'Missing handler for action', action);
            var error = new Error("Missing handler for action '" + action.kind + "'");
            if (action_1.isRequestAction(action)) {
                var deferred = this.requests.get(action.requestId);
                if (deferred !== undefined) {
                    this.requests.delete(action.requestId);
                    deferred.reject(error);
                }
            }
            return Promise.reject(error);
        }
        this.logger.log(this, 'Handle', action);
        var promises = [];
        for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
            var handler = handlers_1[_i];
            var result = handler.handle(action);
            if (action_1.isAction(result)) {
                promises.push(this.dispatch(result));
            }
            else if (result !== undefined) {
                promises.push(this.commandStack.execute(result));
                this.blockUntil = result.blockUntil;
            }
        }
        return Promise.all(promises);
    };
    ActionDispatcher.prototype.handleBlocked = function (action, predicate) {
        var _this = this;
        if (predicate(action)) {
            this.blockUntil = undefined;
            var result = this.handleAction(action);
            var actions = this.postponedActions;
            this.postponedActions = [];
            for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
                var a = actions_1[_i];
                this.dispatch(a.action).then(a.resolve, a.reject);
            }
            return result;
        }
        else {
            this.logger.log(this, 'Action is postponed due to block condition', action);
            return new Promise(function (resolve, reject) {
                _this.postponedActions.push({ action: action, resolve: resolve, reject: reject });
            });
        }
    };
    __decorate([
        inversify_1.inject(types_1.TYPES.ActionHandlerRegistryProvider),
        __metadata("design:type", Function)
    ], ActionDispatcher.prototype, "actionHandlerRegistryProvider", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.ICommandStack),
        __metadata("design:type", Object)
    ], ActionDispatcher.prototype, "commandStack", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
    ], ActionDispatcher.prototype, "logger", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.AnimationFrameSyncer),
        __metadata("design:type", animation_frame_syncer_1.AnimationFrameSyncer)
    ], ActionDispatcher.prototype, "syncer", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.IDiagramLocker),
        __metadata("design:type", Object)
    ], ActionDispatcher.prototype, "diagramLocker", void 0);
    ActionDispatcher = __decorate([
        inversify_1.injectable()
    ], ActionDispatcher);
    return ActionDispatcher;
}());
exports.ActionDispatcher = ActionDispatcher;
//# sourceMappingURL=action-dispatcher.js.map