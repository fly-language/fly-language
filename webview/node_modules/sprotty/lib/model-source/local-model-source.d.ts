/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
import { Bounds } from "../utils/geometry";
import { ILogger } from "../utils/logging";
import { FluentIterable } from '../utils/iterable';
import { Action } from "../base/actions/action";
import { ActionHandlerRegistry } from "../base/actions/action-handler";
import { RequestModelAction } from "../base/features/set-model";
import { SModelElementSchema, SModelIndex, SModelRootSchema } from "../base/model/smodel";
import { Viewport } from '../features/viewport/model';
import { ExportSvgAction } from '../features/export/svg-exporter';
import { RequestPopupModelAction } from "../features/hover/hover";
import { Match } from "../features/update/model-matching";
import { ModelSource, ComputedBoundsApplicator } from "./model-source";
/**
 * A model source that allows to set and modify the model through function calls.
 * This class can be used as a facade over the action-based API of sprotty. It handles
 * actions for bounds calculation and model updates.
 */
export declare class LocalModelSource extends ModelSource {
    protected readonly logger: ILogger;
    protected readonly computedBoundsApplicator: ComputedBoundsApplicator;
    protected popupModelProvider?: IPopupModelProvider;
    protected layoutEngine?: IModelLayoutEngine;
    protected currentRoot: SModelRootSchema;
    /**
     * The `type` property of the model root is used to determine whether a model update
     * is a change of the previous model or a totally new one.
     */
    protected lastSubmittedModelType: string;
    get model(): SModelRootSchema;
    set model(root: SModelRootSchema);
    initialize(registry: ActionHandlerRegistry): void;
    /**
     * Set the model without incremental update.
     */
    setModel(newRoot: SModelRootSchema): Promise<void>;
    commitModel(newRoot: SModelRootSchema): Promise<SModelRootSchema> | SModelRootSchema;
    /**
     * Apply an incremental update to the model with an animation showing the transition to
     * the new state. If `newRoot` is undefined, the current root is submitted; in that case
     * it is assumed that it has been modified before.
     */
    updateModel(newRoot?: SModelRootSchema): Promise<void>;
    /**
     * Get the current selection from the model.
     */
    getSelection(): Promise<FluentIterable<SModelElementSchema>>;
    /**
     * Get the current viewport from the model.
     */
    getViewport(): Promise<Viewport & {
        canvasBounds: Bounds;
    }>;
    /**
     * If client layout is active, run a `RequestBoundsAction` and wait for the resulting
     * `ComputedBoundsAction`, otherwise call `doSubmitModel(â€¦)` directly.
     */
    protected submitModel(newRoot: SModelRootSchema, update: boolean | Match[], cause?: Action): Promise<void>;
    /**
     * Submit the given model with an `UpdateModelAction` or a `SetModelAction` depending on the
     * `update` argument. If available, the model layout engine is invoked first.
     */
    protected doSubmitModel(newRoot: SModelRootSchema, update: boolean | Match[], cause?: Action, index?: SModelIndex<SModelElementSchema>): Promise<void>;
    /**
     * Modify the current model with an array of matches.
     */
    applyMatches(matches: Match[]): Promise<void>;
    /**
     * Modify the current model by adding new elements.
     */
    addElements(elements: (SModelElementSchema | {
        element: SModelElementSchema;
        parentId: string;
    })[]): Promise<void>;
    /**
     * Modify the current model by removing elements.
     */
    removeElements(elements: (string | {
        elementId: string;
        parentId: string;
    })[]): Promise<void>;
    handle(action: Action): void;
    protected handleRequestModel(action: RequestModelAction): void;
    protected handleRequestPopupModel(action: RequestPopupModelAction): void;
    protected handleExportSvgAction(action: ExportSvgAction): void;
}
/**
 * @deprecated Use IPopupModelProvider instead.
 */
export declare type PopupModelFactory = (request: RequestPopupModelAction, element?: SModelElementSchema) => SModelRootSchema | undefined;
export interface IPopupModelProvider {
    getPopupModel(request: RequestPopupModelAction, element?: SModelElementSchema): SModelRootSchema | undefined;
}
export interface IModelLayoutEngine {
    layout(model: SModelRootSchema, index?: SModelIndex<SModelElementSchema>): SModelRootSchema | Promise<SModelRootSchema>;
}
//# sourceMappingURL=local-model-source.d.ts.map