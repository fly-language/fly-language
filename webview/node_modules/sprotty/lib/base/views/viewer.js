"use strict";
/********************************************************************************
 * Copyright (c) 2017-2018 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @jsx html */
var snabbdom_jsx_1 = require("snabbdom-jsx"); // must be html here, as we're creating a div
var snabbdom_1 = require("snabbdom");
var props_1 = require("snabbdom/modules/props");
var attributes_1 = require("snabbdom/modules/attributes");
var style_1 = require("snabbdom/modules/style");
var eventlisteners_1 = require("snabbdom/modules/eventlisteners");
var class_1 = require("snabbdom/modules/class");
var inversify_1 = require("inversify");
var types_1 = require("../types");
var browser_1 = require("../../utils/browser");
var initialize_canvas_1 = require("../features/initialize-canvas");
var vnode_utils_1 = require("./vnode-utils");
var thunk_view_1 = require("./thunk-view");
var smodel_factory_1 = require("../model/smodel-factory");
var ModelRenderer = /** @class */ (function () {
    function ModelRenderer(viewRegistry, targetKind, postprocessors) {
        this.viewRegistry = viewRegistry;
        this.targetKind = targetKind;
        this.postprocessors = postprocessors;
    }
    ModelRenderer.prototype.decorate = function (vnode, element) {
        if (thunk_view_1.isThunk(vnode)) {
            return vnode;
        }
        return this.postprocessors.reduce(function (n, processor) { return processor.decorate(n, element); }, vnode);
    };
    ModelRenderer.prototype.renderElement = function (element, args) {
        var view = this.viewRegistry.get(element.type);
        var vnode = view.render(element, this, args);
        if (vnode) {
            return this.decorate(vnode, element);
        }
        else {
            return undefined;
        }
    };
    ModelRenderer.prototype.renderChildren = function (element, args) {
        var _this = this;
        return element.children
            .map(function (child) { return _this.renderElement(child, args); })
            .filter(function (vnode) { return vnode !== undefined; });
    };
    ModelRenderer.prototype.postUpdate = function (cause) {
        this.postprocessors.forEach(function (processor) { return processor.postUpdate(cause); });
    };
    return ModelRenderer;
}());
exports.ModelRenderer = ModelRenderer;
var PatcherProvider = /** @class */ (function () {
    function PatcherProvider() {
        this.patcher = snabbdom_1.init(this.createModules());
    }
    PatcherProvider.prototype.createModules = function () {
        return [
            props_1.propsModule,
            attributes_1.attributesModule,
            class_1.classModule,
            style_1.styleModule,
            eventlisteners_1.eventListenersModule
        ];
    };
    PatcherProvider = __decorate([
        inversify_1.injectable(),
        __metadata("design:paramtypes", [])
    ], PatcherProvider);
    return PatcherProvider;
}());
exports.PatcherProvider = PatcherProvider;
/**
 * The component that turns the model into an SVG DOM.
 * Uses a VDOM based on snabbdom.js for performance.
 */
var ModelViewer = /** @class */ (function () {
    function ModelViewer(modelRendererFactory, patcherProvider, postprocessors) {
        var _this = this;
        this.onWindowResize = function (vdom) {
            var baseDiv = document.getElementById(_this.options.baseDiv);
            if (baseDiv !== null) {
                var newBounds = _this.getBoundsInPage(baseDiv);
                _this.actiondispatcher.dispatch(new initialize_canvas_1.InitializeCanvasBoundsAction(newBounds));
            }
        };
        this.renderer = modelRendererFactory('main', postprocessors);
        this.patcher = patcherProvider.patcher;
    }
    ModelViewer.prototype.update = function (model, cause) {
        var _this = this;
        this.logger.log(this, 'rendering', model);
        var newVDOM = snabbdom_jsx_1.html("div", { id: this.options.baseDiv }, this.renderer.renderElement(model));
        if (this.lastVDOM !== undefined) {
            var hadFocus = this.hasFocus();
            vnode_utils_1.copyClassesFromVNode(this.lastVDOM, newVDOM);
            this.lastVDOM = this.patcher.call(this, this.lastVDOM, newVDOM);
            this.restoreFocus(hadFocus);
        }
        else if (typeof document !== 'undefined') {
            var placeholder = document.getElementById(this.options.baseDiv);
            if (placeholder !== null) {
                if (typeof window !== 'undefined') {
                    window.addEventListener('resize', function () {
                        _this.onWindowResize(newVDOM);
                    });
                }
                vnode_utils_1.copyClassesFromElement(placeholder, newVDOM);
                vnode_utils_1.setClass(newVDOM, this.options.baseClass, true);
                this.lastVDOM = this.patcher.call(this, placeholder, newVDOM);
            }
            else {
                this.logger.error(this, 'element not in DOM:', this.options.baseDiv);
            }
        }
        this.renderer.postUpdate(cause);
    };
    ModelViewer.prototype.hasFocus = function () {
        if (typeof document !== 'undefined' && document.activeElement && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            var lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === 'object') {
                var lastElement = lastRootVNode.elm;
                return document.activeElement === lastElement;
            }
        }
        return false;
    };
    ModelViewer.prototype.restoreFocus = function (focus) {
        if (focus && this.lastVDOM.children && this.lastVDOM.children.length > 0) {
            var lastRootVNode = this.lastVDOM.children[0];
            if (typeof lastRootVNode === 'object') {
                var lastElement = lastRootVNode.elm;
                if (lastElement && typeof lastElement.focus === 'function')
                    lastElement.focus();
            }
        }
    };
    ModelViewer.prototype.getBoundsInPage = function (element) {
        var bounds = element.getBoundingClientRect();
        var scroll = browser_1.getWindowScroll();
        return {
            x: bounds.left + scroll.x,
            y: bounds.top + scroll.y,
            width: bounds.width,
            height: bounds.height
        };
    };
    __decorate([
        inversify_1.inject(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
    ], ModelViewer.prototype, "options", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
    ], ModelViewer.prototype, "logger", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.IActionDispatcher),
        __metadata("design:type", Object)
    ], ModelViewer.prototype, "actiondispatcher", void 0);
    ModelViewer = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.inject(types_1.TYPES.ModelRendererFactory)),
        __param(1, inversify_1.inject(types_1.TYPES.PatcherProvider)),
        __param(2, inversify_1.multiInject(types_1.TYPES.IVNodePostprocessor)), __param(2, inversify_1.optional()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
    ], ModelViewer);
    return ModelViewer;
}());
exports.ModelViewer = ModelViewer;
/**
 * Viewer for the _hidden_ model. This serves as an intermediate step to compute bounds
 * of elements. The model is rendered in a section that is not visible to the user,
 * and then the bounds are extracted from the DOM.
 */
var HiddenModelViewer = /** @class */ (function () {
    function HiddenModelViewer(modelRendererFactory, patcherProvider, hiddenPostprocessors) {
        this.hiddenRenderer = modelRendererFactory('hidden', hiddenPostprocessors);
        this.patcher = patcherProvider.patcher;
    }
    HiddenModelViewer.prototype.update = function (hiddenModel, cause) {
        this.logger.log(this, 'rendering hidden');
        var newVDOM;
        if (hiddenModel.type === smodel_factory_1.EMPTY_ROOT.type) {
            newVDOM = snabbdom_jsx_1.html("div", { id: this.options.hiddenDiv });
        }
        else {
            var hiddenVNode = this.hiddenRenderer.renderElement(hiddenModel);
            if (hiddenVNode) {
                vnode_utils_1.setAttr(hiddenVNode, 'opacity', 0);
            }
            newVDOM = snabbdom_jsx_1.html("div", { id: this.options.hiddenDiv }, hiddenVNode);
        }
        if (this.lastHiddenVDOM !== undefined) {
            vnode_utils_1.copyClassesFromVNode(this.lastHiddenVDOM, newVDOM);
            this.lastHiddenVDOM = this.patcher.call(this, this.lastHiddenVDOM, newVDOM);
        }
        else {
            var placeholder = document.getElementById(this.options.hiddenDiv);
            if (placeholder === null) {
                placeholder = document.createElement("div");
                document.body.appendChild(placeholder);
            }
            else {
                vnode_utils_1.copyClassesFromElement(placeholder, newVDOM);
            }
            vnode_utils_1.setClass(newVDOM, this.options.baseClass, true);
            vnode_utils_1.setClass(newVDOM, this.options.hiddenClass, true);
            this.lastHiddenVDOM = this.patcher.call(this, placeholder, newVDOM);
        }
        this.hiddenRenderer.postUpdate(cause);
    };
    __decorate([
        inversify_1.inject(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
    ], HiddenModelViewer.prototype, "options", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
    ], HiddenModelViewer.prototype, "logger", void 0);
    HiddenModelViewer = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.inject(types_1.TYPES.ModelRendererFactory)),
        __param(1, inversify_1.inject(types_1.TYPES.PatcherProvider)),
        __param(2, inversify_1.multiInject(types_1.TYPES.HiddenVNodePostprocessor)), __param(2, inversify_1.optional()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
    ], HiddenModelViewer);
    return HiddenModelViewer;
}());
exports.HiddenModelViewer = HiddenModelViewer;
var PopupModelViewer = /** @class */ (function () {
    function PopupModelViewer(modelRendererFactory, patcherProvider, popupPostprocessors) {
        this.modelRendererFactory = modelRendererFactory;
        this.popupRenderer = this.modelRendererFactory('popup', popupPostprocessors);
        this.patcher = patcherProvider.patcher;
    }
    PopupModelViewer.prototype.update = function (model, cause) {
        this.logger.log(this, 'rendering popup', model);
        var popupClosed = model.type === smodel_factory_1.EMPTY_ROOT.type;
        var newVDOM;
        if (popupClosed) {
            newVDOM = snabbdom_jsx_1.html("div", { id: this.options.popupDiv });
        }
        else {
            var position = model.canvasBounds;
            var inlineStyle = {
                top: position.y + 'px',
                left: position.x + 'px'
            };
            newVDOM = snabbdom_jsx_1.html("div", { id: this.options.popupDiv, style: inlineStyle }, this.popupRenderer.renderElement(model));
        }
        if (this.lastPopupVDOM !== undefined) {
            vnode_utils_1.copyClassesFromVNode(this.lastPopupVDOM, newVDOM);
            vnode_utils_1.setClass(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, this.lastPopupVDOM, newVDOM);
        }
        else if (typeof document !== 'undefined') {
            var placeholder = document.getElementById(this.options.popupDiv);
            if (placeholder === null) {
                placeholder = document.createElement("div");
                document.body.appendChild(placeholder);
            }
            else {
                vnode_utils_1.copyClassesFromElement(placeholder, newVDOM);
            }
            vnode_utils_1.setClass(newVDOM, this.options.popupClass, true);
            vnode_utils_1.setClass(newVDOM, this.options.popupClosedClass, popupClosed);
            this.lastPopupVDOM = this.patcher.call(this, placeholder, newVDOM);
        }
        this.popupRenderer.postUpdate(cause);
    };
    __decorate([
        inversify_1.inject(types_1.TYPES.ViewerOptions),
        __metadata("design:type", Object)
    ], PopupModelViewer.prototype, "options", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.ILogger),
        __metadata("design:type", Object)
    ], PopupModelViewer.prototype, "logger", void 0);
    PopupModelViewer = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.inject(types_1.TYPES.ModelRendererFactory)),
        __param(1, inversify_1.inject(types_1.TYPES.PatcherProvider)),
        __param(2, inversify_1.multiInject(types_1.TYPES.PopupVNodePostprocessor)), __param(2, inversify_1.optional()),
        __metadata("design:paramtypes", [Function, PatcherProvider, Array])
    ], PopupModelViewer);
    return PopupModelViewer;
}());
exports.PopupModelViewer = PopupModelViewer;
//# sourceMappingURL=viewer.js.map