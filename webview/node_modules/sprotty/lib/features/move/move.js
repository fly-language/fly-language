"use strict";
/********************************************************************************
 * Copyright (c) 2017-2020 TypeFox and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0
 ********************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var animation_1 = require("../../base/animations/animation");
var command_1 = require("../../base/commands/command");
var smodel_1 = require("../../base/model/smodel");
var smodel_utils_1 = require("../../base/model/smodel-utils");
var types_1 = require("../../base/types");
var mouse_tool_1 = require("../../base/views/mouse-tool");
var vnode_utils_1 = require("../../base/views/vnode-utils");
var sgraph_1 = require("../../graph/sgraph");
var commit_model_1 = require("../../model-source/commit-model");
var geometry_1 = require("../../utils/geometry");
var model_1 = require("../bounds/model");
var create_on_drag_1 = require("../edit/create-on-drag");
var delete_1 = require("../edit/delete");
var edit_routing_1 = require("../edit/edit-routing");
var reconnect_1 = require("../edit/reconnect");
var model_2 = require("../routing/model");
var routing_1 = require("../routing/routing");
var model_3 = require("../edge-layout/model");
var model_4 = require("../select/model");
var select_1 = require("../select/select");
var model_5 = require("../viewport/model");
var model_6 = require("./model");
var MoveAction = /** @class */ (function () {
    function MoveAction(moves, animate, finished) {
        if (animate === void 0) { animate = true; }
        if (finished === void 0) { finished = false; }
        this.moves = moves;
        this.animate = animate;
        this.finished = finished;
        this.kind = MoveCommand.KIND;
    }
    return MoveAction;
}());
exports.MoveAction = MoveAction;
var MoveCommand = /** @class */ (function (_super) {
    __extends(MoveCommand, _super);
    function MoveCommand(action) {
        var _this = _super.call(this) || this;
        _this.action = action;
        _this.resolvedMoves = new Map;
        _this.edgeMementi = [];
        return _this;
    }
    MoveCommand_1 = MoveCommand;
    MoveCommand.prototype.execute = function (context) {
        var _this = this;
        var index = context.root.index;
        var edge2handleMoves = new Map();
        var attachedEdgeShifts = new Map();
        this.action.moves.forEach(function (move) {
            var element = index.getById(move.elementId);
            if (element instanceof model_2.SRoutingHandle && _this.edgeRouterRegistry) {
                var edge = element.parent;
                if (edge instanceof model_2.SRoutableElement) {
                    var resolvedMove = _this.resolveHandleMove(element, edge, move);
                    if (resolvedMove) {
                        var movesByEdge = edge2handleMoves.get(edge);
                        if (!movesByEdge) {
                            movesByEdge = [];
                            edge2handleMoves.set(edge, movesByEdge);
                        }
                        movesByEdge.push(resolvedMove);
                    }
                }
            }
            else if (element && model_6.isLocateable(element)) {
                var resolvedMove_1 = _this.resolveElementMove(element, move);
                if (resolvedMove_1) {
                    _this.resolvedMoves.set(resolvedMove_1.element.id, resolvedMove_1);
                    if (_this.edgeRouterRegistry) {
                        index.getAttachedElements(element).forEach(function (edge) {
                            if (edge instanceof model_2.SRoutableElement) {
                                var existingDelta = attachedEdgeShifts.get(edge);
                                var newDelta = geometry_1.subtract(resolvedMove_1.toPosition, resolvedMove_1.fromPosition);
                                var delta = (existingDelta)
                                    ? geometry_1.linear(existingDelta, newDelta, 0.5)
                                    : newDelta;
                                attachedEdgeShifts.set(edge, delta);
                            }
                        });
                    }
                }
            }
        });
        this.doMove(edge2handleMoves, attachedEdgeShifts);
        if (this.action.animate) {
            this.undoMove();
            return new animation_1.CompoundAnimation(context.root, context, [
                new MoveAnimation(context.root, this.resolvedMoves, context, false),
                new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)
            ]).start();
        }
        return context.root;
    };
    MoveCommand.prototype.resolveHandleMove = function (handle, edge, move) {
        var fromPosition = move.fromPosition;
        if (!fromPosition) {
            var router = this.edgeRouterRegistry.get(edge.routerKind);
            fromPosition = router.getHandlePosition(edge, router.route(edge), handle);
        }
        if (fromPosition)
            return {
                handle: handle,
                fromPosition: fromPosition,
                toPosition: move.toPosition
            };
        return undefined;
    };
    MoveCommand.prototype.resolveElementMove = function (element, move) {
        var fromPosition = move.fromPosition
            || { x: element.position.x, y: element.position.y };
        return {
            element: element,
            fromPosition: fromPosition,
            toPosition: move.toPosition
        };
    };
    MoveCommand.prototype.doMove = function (edge2move, attachedEdgeShifts) {
        var _this = this;
        this.resolvedMoves.forEach(function (res) {
            res.element.position = res.toPosition;
        });
        // reset edges to state before
        edge2move.forEach(function (moves, edge) {
            var router = _this.edgeRouterRegistry.get(edge.routerKind);
            var before = router.takeSnapshot(edge);
            router.applyHandleMoves(edge, moves);
            var after = router.takeSnapshot(edge);
            _this.edgeMementi.push({ edge: edge, before: before, after: after });
        });
        attachedEdgeShifts.forEach(function (delta, edge) {
            if (!edge2move.get(edge)) {
                var router = _this.edgeRouterRegistry.get(edge.routerKind);
                var before = router.takeSnapshot(edge);
                if (edge.source
                    && edge.target
                    && _this.resolvedMoves.get(edge.source.id)
                    && _this.resolvedMoves.get(edge.target.id)) {
                    // move the entire edge when both source and target are moved
                    edge.routingPoints = edge.routingPoints.map(function (rp) { return geometry_1.add(rp, delta); });
                }
                else {
                    // add/remove RPs according to the new source/target positions
                    var updateHandles = model_4.isSelectable(edge) && edge.selected;
                    router.cleanupRoutingPoints(edge, edge.routingPoints, updateHandles, _this.action.finished);
                }
                var after = router.takeSnapshot(edge);
                _this.edgeMementi.push({ edge: edge, before: before, after: after });
            }
        });
    };
    MoveCommand.prototype.undoMove = function () {
        var _this = this;
        this.resolvedMoves.forEach(function (res) {
            res.element.position = res.fromPosition;
        });
        this.edgeMementi.forEach(function (memento) {
            var router = _this.edgeRouterRegistry.get(memento.edge.routerKind);
            router.applySnapshot(memento.edge, memento.before);
        });
    };
    MoveCommand.prototype.undo = function (context) {
        return new animation_1.CompoundAnimation(context.root, context, [
            new MoveAnimation(context.root, this.resolvedMoves, context, true),
            new MorphEdgesAnimation(context.root, this.edgeMementi, context, true)
        ]).start();
    };
    MoveCommand.prototype.redo = function (context) {
        return new animation_1.CompoundAnimation(context.root, context, [
            new MoveAnimation(context.root, this.resolvedMoves, context, false),
            new MorphEdgesAnimation(context.root, this.edgeMementi, context, false)
        ]).start();
    };
    MoveCommand.prototype.merge = function (other, context) {
        var _this = this;
        if (!this.action.animate && other instanceof MoveCommand_1) {
            other.resolvedMoves.forEach(function (otherMove, otherElementId) {
                var existingMove = _this.resolvedMoves.get(otherElementId);
                if (existingMove) {
                    existingMove.toPosition = otherMove.toPosition;
                }
                else {
                    _this.resolvedMoves.set(otherElementId, otherMove);
                }
            });
            other.edgeMementi.forEach(function (otherMemento) {
                var existingMemento = _this.edgeMementi.find(function (edgeMemento) { return edgeMemento.edge.id === otherMemento.edge.id; });
                if (existingMemento) {
                    existingMemento.after = otherMemento.after;
                }
                else {
                    _this.edgeMementi.push(otherMemento);
                }
            });
            return true;
        }
        else if (other instanceof reconnect_1.ReconnectCommand) {
            var otherMemento_1 = other.memento;
            if (otherMemento_1) {
                var existingMemento = this.edgeMementi.find(function (edgeMemento) { return edgeMemento.edge.id === otherMemento_1.edge.id; });
                if (existingMemento) {
                    existingMemento.after = otherMemento_1.after;
                }
                else {
                    this.edgeMementi.push(otherMemento_1);
                }
            }
            return true;
        }
        return false;
    };
    var MoveCommand_1;
    MoveCommand.KIND = 'move';
    __decorate([
        inversify_1.inject(routing_1.EdgeRouterRegistry), inversify_1.optional(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
    ], MoveCommand.prototype, "edgeRouterRegistry", void 0);
    MoveCommand = MoveCommand_1 = __decorate([
        inversify_1.injectable(),
        __param(0, inversify_1.inject(types_1.TYPES.Action)),
        __metadata("design:paramtypes", [MoveAction])
    ], MoveCommand);
    return MoveCommand;
}(command_1.MergeableCommand));
exports.MoveCommand = MoveCommand;
var MoveAnimation = /** @class */ (function (_super) {
    __extends(MoveAnimation, _super);
    function MoveAnimation(model, elementMoves, context, reverse) {
        if (reverse === void 0) { reverse = false; }
        var _this = _super.call(this, context) || this;
        _this.model = model;
        _this.elementMoves = elementMoves;
        _this.reverse = reverse;
        return _this;
    }
    MoveAnimation.prototype.tween = function (t) {
        var _this = this;
        this.elementMoves.forEach(function (elementMove) {
            if (_this.reverse) {
                elementMove.element.position = {
                    x: (1 - t) * elementMove.toPosition.x + t * elementMove.fromPosition.x,
                    y: (1 - t) * elementMove.toPosition.y + t * elementMove.fromPosition.y
                };
            }
            else {
                elementMove.element.position = {
                    x: (1 - t) * elementMove.fromPosition.x + t * elementMove.toPosition.x,
                    y: (1 - t) * elementMove.fromPosition.y + t * elementMove.toPosition.y
                };
            }
        });
        return this.model;
    };
    return MoveAnimation;
}(animation_1.Animation));
exports.MoveAnimation = MoveAnimation;
var MorphEdgesAnimation = /** @class */ (function (_super) {
    __extends(MorphEdgesAnimation, _super);
    function MorphEdgesAnimation(model, originalMementi, context, reverse) {
        if (reverse === void 0) { reverse = false; }
        var _this = _super.call(this, context) || this;
        _this.model = model;
        _this.reverse = reverse;
        _this.expanded = [];
        originalMementi.forEach(function (edgeMemento) {
            var start = _this.reverse ? edgeMemento.after : edgeMemento.before;
            var end = _this.reverse ? edgeMemento.before : edgeMemento.after;
            var startRoute = start.routedPoints;
            var endRoute = end.routedPoints;
            var maxRoutingPoints = Math.max(startRoute.length, endRoute.length);
            _this.expanded.push({
                startExpandedRoute: _this.growToSize(startRoute, maxRoutingPoints),
                endExpandedRoute: _this.growToSize(endRoute, maxRoutingPoints),
                memento: edgeMemento
            });
        });
        return _this;
    }
    MorphEdgesAnimation.prototype.midPoint = function (edgeMemento) {
        var edge = edgeMemento.edge;
        var source = edgeMemento.edge.source;
        var target = edgeMemento.edge.target;
        return geometry_1.linear(smodel_utils_1.translatePoint(geometry_1.center(source.bounds), source.parent, edge.parent), smodel_utils_1.translatePoint(geometry_1.center(target.bounds), target.parent, edge.parent), 0.5);
    };
    MorphEdgesAnimation.prototype.start = function () {
        this.expanded.forEach(function (morph) {
            morph.memento.edge.removeAll(function (e) { return e instanceof model_2.SRoutingHandle; });
        });
        return _super.prototype.start.call(this);
    };
    MorphEdgesAnimation.prototype.tween = function (t) {
        var _this = this;
        if (t === 1) {
            this.expanded.forEach(function (morph) {
                var memento = morph.memento;
                if (_this.reverse)
                    memento.before.router.applySnapshot(memento.edge, memento.before);
                else
                    memento.after.router.applySnapshot(memento.edge, memento.after);
            });
        }
        else {
            this.expanded.forEach(function (morph) {
                var newRoutingPoints = [];
                // ignore source and target anchor
                for (var i = 1; i < morph.startExpandedRoute.length - 1; ++i)
                    newRoutingPoints.push(geometry_1.linear(morph.startExpandedRoute[i], morph.endExpandedRoute[i], t));
                var closestSnapshot = t < 0.5 ? morph.memento.before : morph.memento.after;
                var newSnapshot = __assign(__assign({}, closestSnapshot), { routingPoints: newRoutingPoints, routingHandles: [] });
                closestSnapshot.router.applySnapshot(morph.memento.edge, newSnapshot);
            });
        }
        return this.model;
    };
    MorphEdgesAnimation.prototype.growToSize = function (route, targetSize) {
        var diff = targetSize - route.length;
        if (diff <= 0)
            return route;
        var result = [];
        result.push(route[0]);
        var deltaDiff = 1 / (diff + 1);
        var deltaSmaller = 1 / (route.length - 1);
        var nextInsertion = 1;
        for (var i = 1; i < route.length; ++i) {
            var pos = deltaSmaller * i;
            var insertions = 0;
            while (pos > (nextInsertion + insertions) * deltaDiff)
                ++insertions;
            nextInsertion += insertions;
            for (var j = 0; j < insertions; ++j) {
                var p = geometry_1.linear(route[i - 1], route[i], (j + 1) / (insertions + 1));
                result.push(p);
            }
            result.push(route[i]);
        }
        return result;
    };
    return MorphEdgesAnimation;
}(animation_1.Animation));
exports.MorphEdgesAnimation = MorphEdgesAnimation;
var MoveMouseListener = /** @class */ (function (_super) {
    __extends(MoveMouseListener, _super);
    function MoveMouseListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasDragged = false;
        _this.elementId2startPos = new Map();
        return _this;
    }
    MoveMouseListener.prototype.mouseDown = function (target, event) {
        var result = [];
        if (event.button === 0) {
            var moveable = smodel_utils_1.findParentByFeature(target, model_6.isMoveable);
            var isRoutingHandle = target instanceof model_2.SRoutingHandle;
            if (moveable !== undefined || isRoutingHandle || create_on_drag_1.isCreatingOnDrag(target)) {
                this.startDragPosition = { x: event.pageX, y: event.pageY };
            }
            else {
                this.startDragPosition = undefined;
            }
            this.hasDragged = false;
            if (create_on_drag_1.isCreatingOnDrag(target)) {
                result.push(new select_1.SelectAllAction(false));
                result.push(target.createAction(model_2.edgeInProgressID));
                result.push(new select_1.SelectAction([model_2.edgeInProgressID], []));
                result.push(new edit_routing_1.SwitchEditModeAction([model_2.edgeInProgressID], []));
                result.push(new select_1.SelectAction([model_2.edgeInProgressTargetHandleID], []));
                result.push(new edit_routing_1.SwitchEditModeAction([model_2.edgeInProgressTargetHandleID], []));
            }
            else if (isRoutingHandle) {
                result.push(new edit_routing_1.SwitchEditModeAction([target.id], []));
            }
        }
        return result;
    };
    MoveMouseListener.prototype.mouseMove = function (target, event) {
        var result = [];
        if (event.buttons === 0)
            this.mouseUp(target, event);
        else if (this.startDragPosition) {
            if (this.elementId2startPos.size === 0) {
                this.collectStartPositions(target.root);
            }
            this.hasDragged = true;
            var moveAction = this.getElementMoves(target, event, false);
            if (moveAction)
                result.push(moveAction);
        }
        return result;
    };
    MoveMouseListener.prototype.collectStartPositions = function (root) {
        var _this = this;
        root.index.all()
            .filter(function (element) { return model_4.isSelectable(element) && element.selected; })
            .forEach(function (element) {
            if (model_6.isMoveable(element))
                _this.elementId2startPos.set(element.id, element.position);
            else if (element instanceof model_2.SRoutingHandle) {
                var position = _this.getHandlePosition(element);
                if (position)
                    _this.elementId2startPos.set(element.id, position);
            }
        });
    };
    MoveMouseListener.prototype.getElementMoves = function (target, event, isFinished) {
        var _this = this;
        if (!this.startDragPosition)
            return undefined;
        var elementMoves = [];
        var viewport = smodel_utils_1.findParentByFeature(target, model_5.isViewport);
        var zoom = viewport ? viewport.zoom : 1;
        var delta = {
            x: (event.pageX - this.startDragPosition.x) / zoom,
            y: (event.pageY - this.startDragPosition.y) / zoom
        };
        this.elementId2startPos.forEach(function (startPosition, elementId) {
            var element = target.root.index.getById(elementId);
            if (element) {
                var toPosition = _this.snap({
                    x: startPosition.x + delta.x,
                    y: startPosition.y + delta.y
                }, element, !event.shiftKey);
                if (model_6.isMoveable(element)) {
                    elementMoves.push({
                        elementId: element.id,
                        fromPosition: {
                            x: element.position.x,
                            y: element.position.y
                        },
                        toPosition: toPosition
                    });
                }
                else if (element instanceof model_2.SRoutingHandle) {
                    var point = _this.getHandlePosition(element);
                    if (point !== undefined) {
                        elementMoves.push({
                            elementId: element.id,
                            fromPosition: point,
                            toPosition: toPosition
                        });
                    }
                }
            }
        });
        if (elementMoves.length > 0)
            return new MoveAction(elementMoves, false, isFinished);
        else
            return undefined;
    };
    MoveMouseListener.prototype.snap = function (position, element, isSnap) {
        if (isSnap && this.snapper)
            return this.snapper.snap(position, element);
        else
            return position;
    };
    MoveMouseListener.prototype.getHandlePosition = function (handle) {
        if (this.edgeRouterRegistry) {
            var parent_1 = handle.parent;
            if (!(parent_1 instanceof model_2.SRoutableElement))
                return undefined;
            var router = this.edgeRouterRegistry.get(parent_1.routerKind);
            var route = router.route(parent_1);
            return router.getHandlePosition(parent_1, route, handle);
        }
        return undefined;
    };
    MoveMouseListener.prototype.mouseEnter = function (target, event) {
        if (target instanceof smodel_1.SModelRoot && event.buttons === 0)
            this.mouseUp(target, event);
        return [];
    };
    MoveMouseListener.prototype.mouseUp = function (target, event) {
        var _this = this;
        var result = [];
        var hasReconnected = false;
        if (this.startDragPosition) {
            var moveAction = this.getElementMoves(target, event, true);
            if (moveAction)
                result.push(moveAction);
            target.root.index.all()
                .forEach(function (element) {
                if (element instanceof model_2.SRoutingHandle) {
                    var parent_2 = element.parent;
                    if (parent_2 instanceof model_2.SRoutableElement && element.danglingAnchor) {
                        var handlePos = _this.getHandlePosition(element);
                        if (handlePos) {
                            var handlePosAbs = smodel_utils_1.translatePoint(handlePos, element.parent, element.root);
                            var newEnd = model_1.findChildrenAtPosition(target.root, handlePosAbs)
                                .find(function (e) { return model_2.isConnectable(e) && e.canConnect(parent_2, element.kind); });
                            if (newEnd && _this.hasDragged) {
                                result.push(new reconnect_1.ReconnectAction(element.parent.id, element.kind === 'source' ? newEnd.id : parent_2.sourceId, element.kind === 'target' ? newEnd.id : parent_2.targetId));
                                hasReconnected = true;
                            }
                        }
                    }
                    if (element.editMode)
                        result.push(new edit_routing_1.SwitchEditModeAction([], [element.id]));
                }
            });
        }
        if (!hasReconnected) {
            var edgeInProgress = target.root.index.getById(model_2.edgeInProgressID);
            if (edgeInProgress instanceof smodel_1.SChildElement) {
                var deleteIds_1 = [];
                deleteIds_1.push(model_2.edgeInProgressID);
                edgeInProgress.children.forEach(function (c) {
                    if (c instanceof model_2.SRoutingHandle && c.danglingAnchor)
                        deleteIds_1.push(c.danglingAnchor.id);
                });
                result.push(new delete_1.DeleteElementAction(deleteIds_1));
            }
        }
        if (this.hasDragged)
            result.push(new commit_model_1.CommitModelAction());
        this.hasDragged = false;
        this.startDragPosition = undefined;
        this.elementId2startPos.clear();
        return result;
    };
    MoveMouseListener.prototype.decorate = function (vnode, element) {
        return vnode;
    };
    __decorate([
        inversify_1.inject(routing_1.EdgeRouterRegistry), inversify_1.optional(),
        __metadata("design:type", routing_1.EdgeRouterRegistry)
    ], MoveMouseListener.prototype, "edgeRouterRegistry", void 0);
    __decorate([
        inversify_1.inject(types_1.TYPES.ISnapper), inversify_1.optional(),
        __metadata("design:type", Object)
    ], MoveMouseListener.prototype, "snapper", void 0);
    return MoveMouseListener;
}(mouse_tool_1.MouseListener));
exports.MoveMouseListener = MoveMouseListener;
var LocationPostprocessor = /** @class */ (function () {
    function LocationPostprocessor() {
    }
    LocationPostprocessor.prototype.decorate = function (vnode, element) {
        if (model_3.isEdgeLayoutable(element) && element.parent instanceof sgraph_1.SEdge) {
            // The element is handled by EdgeLayoutDecorator
            return vnode;
        }
        var translate = '';
        if (model_6.isLocateable(element) && element instanceof smodel_1.SChildElement && element.parent !== undefined) {
            var pos = element.position;
            if (pos.x !== 0 || pos.y !== 0) {
                translate = 'translate(' + pos.x + ', ' + pos.y + ')';
            }
        }
        if (model_1.isAlignable(element)) {
            var ali = element.alignment;
            if (ali.x !== 0 || ali.y !== 0) {
                if (translate.length > 0) {
                    translate += ' ';
                }
                translate += 'translate(' + ali.x + ', ' + ali.y + ')';
            }
        }
        if (translate.length > 0) {
            vnode_utils_1.setAttr(vnode, 'transform', translate);
        }
        return vnode;
    };
    LocationPostprocessor.prototype.postUpdate = function () {
    };
    LocationPostprocessor = __decorate([
        inversify_1.injectable()
    ], LocationPostprocessor);
    return LocationPostprocessor;
}());
exports.LocationPostprocessor = LocationPostprocessor;
//# sourceMappingURL=move.js.map